""" Mixer tuner based on a straight-forward parameter minimizer obtained from on Yale-qrlab implementation by Reiner Heeres, all credits to them. I have only used those functions that are needed to do mixer tuning for our setup (and added missing functions where necessary) """

import time

import numpy as np
import matplotlib.pyplot as plt

from qm.qua import infinite_loop_, program

import qcrew.control.instruments.qm as qciqm
from qcrew.control.instruments.signal_hound.sa124 import Sa124


class Parameter:
    def __init__(self, name, value, vrange, minstep=0):
        self.name = name
        self.value = value
        self.vrange = vrange
        self.minstep = minstep


class Minimizer:
    """
    Straight-forward parameter optimizer.

    Optimization strategy:
    - Repeat <n_it> times (default: 5):
        - For each parameter:
            - sweep parameter from (value - range/2) to (value + range/2) in
              <n_eval> steps (default: 6) and evaluate function.
            - determine best parameter value.
            - reduce range by a factor <range_div> (default: 2.5).

    Specify optimization function <func>, it's arguments <args> and keyword
    arguments <kwargs>. The function should accept a dictionary of Parameter
    objects as it's first argument. It should return a scalar.
    """

    def __init__(
        self,
        func,
        args=(),
        kwargs={},
        n_eval=6,
        n_it=5,
        range_div=2.5,
        verbose=False,
        plot=False,
    ):
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.params = {}
        self.n_eval = n_eval
        self.n_it = n_it
        self.verbose = verbose
        self.range_div = range_div
        self.plot = plot

    def add_parameter(self, p):
        self.params[p.name] = p

    def minimize(self, min_step=None):
        if self.plot:
            fig, [axes_list, min_list] = plt.subplots(
                2, len(self.params), sharex=False, sharey=False
            )

        for i_it in range(self.n_it):  # for n iterations
            # for each param to minimize
            for i_p, (pname, p) in enumerate(self.params.items()):
                # obtain initial value from parameter
                p_val0 = p.value

                # by default, sweep points are generated by np.linspace
                p_vals = np.linspace(
                    p_val0 - p.vrange / 2, p_val0 + p.vrange / 2, self.n_eval
                )

                # but if the step size is too small, ignore n_eval set by user and use p.minstep to decide sweep points with np.arange
                # include endpoint (that's what the +0.00001 is doing)
                if np.abs(p_vals[1] - p_vals[0]) < p.minstep:
                    p_vals = np.arange(p_vals[0], p_vals[-1] + 0.00001, p.minstep)
                # trivial case, nothing to minimize here
                if len(p_vals) == 1:
                    break

                vs = []
                # evaluate each value with the objective function and store it in a list
                for p_val in p_vals:
                    p.value = p_val
                    vs.append(self.func(self.params, *self.args, **self.kwargs))
                # find the minimum value evaluated
                vs = np.array(vs)
                imin = np.argmin(vs)
                p.value = p_vals[imin]
                # print additional info if verbose flag is on
                if self.verbose:
                    print(
                        f"Iteration: {i_it}, Param: {pname}, Minimized value = {vs[imin]:.3} at param value {p.value:.3}, Step size: {p_vals[1] - p_vals[0]:.3}"
                    )
                if self.plot:
                    axes_list[i_p].plot(p_vals, vs)

                    min_list[i_p].plot(p_vals, vs)
                    min_list[i_p].set_ylim(vs.min(), vs.max())
                    min_list[i_p].set_xlim(p_vals.min(), p_vals.max())

                p.vrange /= self.range_div  # reduce sweep range for next iteration

        # If live optimizing, set final parameters
        self.func(self.params, *self.args, **self.kwargs)

        return self.params


class YaleMixerTuner:
    """We can calibrate one mode at one time using this class"""

    def __init__(self, mode, sa, qm):
        """mode: must be a Mode object
        sa: the spectrum analyzer instance
        qm: the QuantumMachine instance (must be already configured)
        """
        self.mode = mode
        self.sa = sa
        self.qm = qm
        # will be set by setup_lo() and setup_osb() and halted by clean_up()
        self.qm_job = None

        # we want to minimize these
        self.lo_freq = self.mode.lo_freq
        self.sb_freq = self.mode.lo_freq - self.mode.int_freq

    def setup_lo(self, amp=None):
        # play int freq
        self.qm_job = self.qm.execute(self._get_qua_program(self.mode))
        # set sa center freq
        amp = self.sa.single_sweep(
            center=self.lo_freq, verify_freq=True, set_zeroif_params=True
        )
        print(f"Initial amp of lo leakage: {amp}")

    def setup_osb(self, amp=None):
        # play pulse at IF with QM
        self.qm_job = self.qm.execute(self._get_qua_program(self.mode))
        # set sa center freq with self.lo_freq + self.int_freq
        amp = self.sa.single_sweep(
            center=self.sb_freq,
            verify_freq=True,
            set_zeroif_params=True,
        )
        print(f"Initial amp of sb leakage: {amp}")

    def clean_up(self):
        """ """
        sweep_parameters = {
            "center": self.lo_freq,
            "span": 500e6,
            "rbw": Sa124.default_rbw,
            "ref_power": Sa124.default_ref_power,
        }
        freqs, amps = self.sa.sweep(**sweep_parameters)
        f = plt.figure(2)
        plt.plot(freqs, amps)
        f.canvas.draw()
        #plt.show(block=False)
        self.qm_job.halt()

    def _lo_func(self, params, delay=0.1):
        i_offset, q_offset = params["I"].value, params["Q"].value
        mode_name = self.mode.name
        self.qm.set_output_dc_offset_by_element(mode_name, "I", i_offset)
        self.qm.set_output_dc_offset_by_element(mode_name, "Q", q_offset)
        time.sleep(delay)
        val = self.sa.single_sweep(self.lo_freq)
        print(f"Measuring at I: {i_offset}, Q: {q_offset}, amp: {val}")
        return val

    def _osb_func(self, params, delay=0.2):
        g_offset, p_offset = params["G"].value, params["P"].value
        correction_matrix = qciqm.QMConfig.get_mixer_correction_matrix(
            g_offset, p_offset
        )
        self.qm_job.set_element_correction(self.mode.name, correction_matrix)
        time.sleep(delay)
        val = self.sa.single_sweep(self.sb_freq)
        print(f"Measuring at G: {g_offset}, P: {p_offset}, amp: {val}")
        return val

    def minimize(
        self,
        func,
        param_names,
        init0,
        init1,
        range0,
        range1,
        n_it=4,
        n_eval=11,
        range_div=4,
        plot = False,
        verbose = False,
    ):
        p0, p1 = param_names
        m = Minimizer(func, n_it=n_it, n_eval=n_eval, range_div=range_div, verbose=verbose, plot=plot)
        m.add_parameter(Parameter(p0, value=init0, vrange=range0))
        m.add_parameter(Parameter(p1, value=init1, vrange=range1))
        m.minimize()
        return m.params

    def minimize_lo_leakage(self, range0, range1, reset_vals=True, **kwargs):
        if reset_vals:
            i_offset, q_offset = 0.0, 0.0
        else:
            i_offset, q_offset = (
                self.mode.mixer_offsets["I"],
                self.mode.mixer_offsets["Q"],
            )
        self.setup_lo()
        opt_params = self.minimize(
            self._lo_func, ("I", "Q"), i_offset, q_offset, range0, range1, **kwargs
        )
        min_i_offset, min_q_offset = opt_params["I"].value, opt_params["Q"].value
        print(f"Done minimizing LO leakage! {min_i_offset = }, {min_q_offset = }")
        self.mode.mixer_offsets = {"I": min_i_offset, "Q": min_q_offset}
        self.clean_up()
        return opt_params

    def minimize_sb_leakage(self, range0, range1, reset_vals=True, **kwargs):
        if reset_vals:
            g_offset, p_offset = 0.0, 0.0
        else:
            g_offset, p_offset = (
                self.mode.mixer_offsets["G"],
                self.mode.mixer_offsets["P"],
            )
        self.setup_osb()
        opt_params = self.minimize(
            self._osb_func, ("G", "P"), g_offset, p_offset, range0, range1, **kwargs
        )
        min_g_offset, min_p_offset = opt_params["G"].value, opt_params["P"].value
        correction_matrix = qciqm.QMConfig.get_mixer_correction_matrix(
            min_g_offset, min_p_offset
        )
        print(f"Done minimizing SB leakage! {min_g_offset = }, {min_p_offset = }")
        print(f"Final {correction_matrix = }")
        self.mode.mixer_offsets = {"G": min_g_offset, "P": min_p_offset}
        self.clean_up()
        return opt_params

    def _get_qua_program(self, mode):
        """ """
        with program() as mixer_tuning:
            with infinite_loop_():
                mode.play("constant_pulse")
        return mixer_tuning
